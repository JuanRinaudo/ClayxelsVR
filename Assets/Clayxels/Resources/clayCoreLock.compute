#pragma kernel computeGrid
#pragma kernel generatePointCloud
#pragma kernel debugDisplayGridPoints
#pragma kernel genMesh
#pragma kernel clearGrid
#pragma kernel filterSolidsPerChunk
#include"claySDF.compute"
RWStructuredBuffer<float3> gridData;RWStructuredBuffer<int4> pointCloudData;StructuredBuffer<int> triangleConnectionTable;RWStructuredBuffer<int> indirectDrawArgs,numSolidsPerChunk,updatingChunks;struct SolidPerChunk{int solids[512];};RWStructuredBuffer<SolidPerChunk> solidsPerChunk;struct PrefilteredSolidSlice{int solids[128];};RWStructuredBuffer<PrefilteredSolidSlice> prefilteredSolidIds;
#if DRAW_DEBUG
RWStructuredBuffer<float3> debugGridOutPoints;
#endif
StructuredBuffer<float3> solidsPos;StructuredBuffer<float4> solidsRot;StructuredBuffer<float3> solidsScale;StructuredBuffer<float> solidsBlend;StructuredBuffer<int> solidsType;StructuredBuffer<float3> solidsColor;StructuredBuffer<float4> solidsAttrs;StructuredBuffer<int> solidsUpdated;RWStructuredBuffer<int3> meshOutIndices;RWStructuredBuffer<float3> meshOutPoints;RWStructuredBuffer<float4> meshOutColors;uint chunkId=0,numSolids=0,numSolidsBlending=0;float chunkSize=20.;float3 chunkCenter=float3(0.,0.,0.);int numChunksX=0,numChunksY=0,numChunksZ=0,outMeshIndexOffset=0;float surfaceBoundaryThreshold=.5,solidsMaxInfluence=0.;uint numSolidsUpdated=0;static const int3 localGridCellCoords[8]={int3(0,0,0),int3(1,0,0),int3(1,1,0),int3(0,1,0),int3(0,0,1),int3(1,0,1),int3(1,1,1),int3(0,1,1)};static const float3 vertexOffset[8]={float3(0,0,0),float3(1,0,0),float3(1,1,0),float3(0,1,0),float3(0,0,1),float3(1,0,1),float3(1,1,1),float3(0,1,1)};static const int2 edgeConnection[12]={int2(0,1),int2(1,2),int2(2,3),int2(3,0),int2(4,5),int2(5,6),int2(6,7),int2(7,4),int2(0,4),int2(1,5),int2(2,6),int2(3,7)};static const float3 edgeDirection[12]={float3(1.f,0.f,0.f),float3(0.f,1.f,0.f),float3(-1.f,0.f,0.f),float3(0.f,-1.f,0.f),float3(1.f,0.f,0.f),float3(0.f,1.f,0.f),float3(-1.f,0.f,0.f),float3(0.f,-1.f,0.f),float3(0.f,0.f,1.f),float3(0.f,0.f,1.f),float3(0.f,0.f,1.f),float3(0.f,0.f,1.f)},cardinalCellOffset[8]={float3(-1,-1,-1),float3(1,-1,-1),float3(1,1,-1),float3(-1,1,-1),float3(-1,-1,1),float3(1,-1,1),float3(1,1,1),float3(-1,1,1)};static const int cubeEdgeFlags[]={0,265,515,778,1030,1295,1541,1804,2060,2309,2575,2822,3082,3331,3593,3840,400,153,915,666,1430,1183,1941,1692,2460,2197,2975,2710,3482,3219,3993,3728,560,825,51,314,1590,1855,1077,1340,2620,2869,2111,2358,3642,3891,3129,3376,928,681,419,170,1958,1711,1445,1196,2988,2725,2479,2214,4010,3747,3497,3232,1120,1385,1635,1898,102,367,613,876,3180,3429,3695,3942,2154,2403,2665,2912,1520,1273,2035,1786,502,255,1013,764,3580,3317,4095,3830,2554,2291,3065,2800,1616,1881,1107,1370,598,863,85,348,3676,3925,3167,3414,2650,2899,2137,2384,1984,1737,1475,1226,966,719,453,204,4044,3781,3535,3270,3018,2755,2505,2240,2240,2505,2755,3018,3270,3535,3781,4044,204,453,719,966,1226,1475,1737,1984,2384,2137,2899,2650,3414,3167,3925,3676,348,85,863,598,1370,1107,1881,1616,2800,3065,2291,2554,3830,4095,3317,3580,764,1013,255,502,1786,2035,1273,1520,2912,2665,2403,2154,3942,3695,3429,3180,876,613,367,102,1898,1635,1385,1120,3232,3497,3747,4010,2214,2479,2725,2988,1196,1445,1711,1958,170,419,681,928,3376,3129,3891,3642,2358,2111,2869,2620,1340,1077,1855,1590,314,51,825,560,3728,3993,3219,3482,2710,2975,2197,2460,1692,1941,1183,1430,666,915,153,400,3840,3593,3331,3082,2822,2575,2309,2060,1804,1541,1295,1030,778,515,265,0};int f(int f,int i,int s,int c){return f+c*(i+c*s);}uint f(float3 f){uint s=uint(f.x*255)+uint(f.y*255)*256+uint(f.z*255)*256*256;return s;}float f(float f,float i,float s){float c=max(s-abs(f-i),0.);return min(f,i)-c*c*.25f/s;}float s(float f,float i,float s){float e=abs(s),c=max(e-abs(-f-i),0.);return max(-f,i)+c*c*.25/e;}bool f(int4 s,int f){if(f>63)return false;uint e=uint(f)/32;int i=s[e],u=f-32*e;if(i>>u&1)return true;return false;}void s(uint f,inout int4 s){uint e=f/32;int i=s[e],u=f-32*e;i=i&~(1<<u);if(e==0)s.x=i;else if(e==1)s.y=i;else if(e==2)s.z=i;else if(e==3)s.w=i;}bool s(int f){return f>>0&1;}float f(float3 i,float c,inout int4 u,float S,uint e,uint x){float z=1e+10;int t=0;for(uint r=0;r<e;++r){if(!f(u,r)){continue;}uint d=prefilteredSolidIds[x].solids[r];float g=solidsBlend[d];float4 M=solidsAttrs[d];float y=computeClayDistanceFunction(solidsType[d],i,solidsPos[d],solidsRot[d],solidsScale[d],M);if(!s(M.w)){if(g==0.)z=min(y,z);else if(g>0.)z=f(y,z,g);else z=s(y,z,g);}if(y>S)s(r,u);S-=abs(g);}return z;}float f(float3 i,float c,out int z,out float3 u,int4 y,uint e,uint d){float r=1e+10;u=float3(1.,1.,1.);for(uint g=0;g<e;++g){if(!f(y,g)){continue;}uint t=prefilteredSolidIds[d].solids[g];float x=solidsBlend[t];float3 M=solidsColor[t];float4 n=solidsAttrs[t];float S=computeClayDistanceFunction(solidsType[t],i,solidsPos[t],solidsRot[t],solidsScale[t],n);if(S<r)z=t;bool D=s(n.w);if(x==0.){float m=clamp((r-S)/(c*2.),0.,1.);u=lerp(u,M,m);if(!D)r=min(S,r);}else if(x>0.){float m=clamp(.5+.5*(S-r)/x,0.,1.);u=lerp(M,u,m);if(!D)r=f(S,r,x);}else{float m=clamp(.5+.5*(-S-r)/x,0.,1.);u=lerp(M,u,m);if(!D)r=s(S,r,x);if(m<.5)z=t;}}return r;}float f(float3 i,float y,out int z,out float3 r,int4 u){float e=1e+10;r=float3(1.,1.,1.);int c=0;for(uint t=0;t<numSolids;++t){if(!f(u,t)){continue;}c+=1;float g=solidsBlend[t];float3 m=solidsColor[t];float x=computeClayDistanceFunction(solidsType[t],i,solidsPos[t],solidsRot[t],solidsScale[t],solidsAttrs[t]);if(x<e)z=t;if(g==0.)e=min(x,e);else if(g>0.)e=f(x,e,g);else e=s(x,e,g);}float g=float(c-1)/float(numSolids-1);r=lerp(float3(0.,0.,1.),float3(1.,0.,0.),g);return e;}float3 r(int f){int i=(f&255)>>0,e=(f&65280)>>8,u=(f&16711680)>>16;return float3(i/255.,e/255.,u/255.);}bool t(int3 f){if(f.x<0)return true;if(f.x>255)return true;if(f.y<0)return true;if(f.y>255)return true;if(f.z<0)return true;if(f.z>255)return true;return false;}float c(int4 f){float e=0.;for(uint i=0;i<numSolids;++i)e+=abs(solidsBlend[i]);return e;}float3 c(int3 f,float i){float e=i*.5,z=chunkSize*.5;float3 s=float3(i*f.x-z,i*f.y-z,i*f.z-z)+e;return s;}void c(float3 f,float i,uint t,inout uint e,inout float s){prefilteredSolidIds[t].solids[0]=-1;uint c=numSolidsPerChunk[chunkId],r=0;for(r=0;r<c;++r){uint d=solidsPerChunk[chunkId].solids[r];float3 u=solidsScale[d],g=f;if(int(solidsAttrs[d].w)>>1&1)g.x=abs(g.x);float z=max(u.x,max(u.y,u.z))*1.732,M=length(solidsPos[d]-g)-z;if(M<2.){prefilteredSolidIds[t].solids[e]=d;e+=1;s+=abs(solidsBlend[d]);if(e==128){break;}}}}[numthreads(MAXTHREADS,MAXTHREADS,MAXTHREADS)]void computeGrid(int3 i:SV_DispatchThreadID){float s=chunkSize/64;float3 e=c(i,s);int z=f(i.x,i.y,i.z,64);uint u=0;float g=0.;c(e+chunkCenter,s*.5,z,u,g);int4 r=int4(-1,-1,-1,-1);float t=f(e+chunkCenter,s,r,g+s,u,z);if(abs(t)<s*surfaceBoundaryThreshold){float m=s*.25,x=m*.5,M=s*.5*surfaceBoundaryThreshold,D=chunkSize/256,n=chunkSize*.5;for(uint d=0;d<8;++d){float3 y=e+m*cardinalCellOffset[d];for(uint S=0;S<8;++S){float3 k=y+x*cardinalCellOffset[S];int3 v=int3(round((k.x+n-x)/D),round((k.y+n-x)/D),round((k.z+n-x)/D));int p=f(v.x,v.y,v.z,256),o=0;float3 w=float3(1.,1.,1.);float a=f(k+chunkCenter,x,o,w,r,u,z);if(abs(a)<M)gridData[p]=float3(a,f(w),o+1);}}}}[numthreads(MAXTHREADS,MAXTHREADS,MAXTHREADS)]void clearGrid(int3 i:SV_DispatchThreadID){float s=chunkSize/64;float3 e=c(i,s);int t=f(i.x,i.y,i.z,64);if(t==0)indirectDrawArgs[0]=0;if(prefilteredSolidIds[t].solids[0]!=-1){prefilteredSolidIds[t].solids[0]=-1;float m=s*.25,z=m*.5,u=s*.5*surfaceBoundaryThreshold,g=chunkSize/256,r=chunkSize*.5;for(uint d=0;d<8;++d){float3 y=e+m*cardinalCellOffset[d];for(uint x=0;x<8;++x){float3 k=y+z*cardinalCellOffset[x];int3 M=int3(round((k.x+r-z)/g),round((k.y+r-z)/g),round((k.z+r-z)/g));int n=f(M.x,M.y,M.z,256);gridData[n]=float3(0.,0.,0.);}}}}float r(float f,float s){float i=s-f,t=.5;if(i!=0.)t=f/i;return t;}float2 i(float2 f){float2 e=f.xy>=0.?1.:-1.,t=(1.-abs(f.yx))*e;return t;}float d(float2 f){int i=2048;float s=floor(f.x*(i-1)),e=floor(f.y*(i-1)),u=s*i+e;return u;}float m(float3 f){f/=abs(f.x)+abs(f.y)+abs(f.z);f.xy=f.z>=0.?f.xy:i(f.xy);f.xy=f.xy*.5+.5;float e=d(f.xy);return e;}int c(uint f,uint i,uint r,uint s){int e=f<<24|i<<16|r<<8|s;return e;}float u(float3 f){float e=dot(round(f*255),float3(65536,256,1));return e;}groupshared int4 gs_pointCloudData[256];groupshared uint gs_numElements,gs_globalOffset;void c(int3 i,float e,int s){int t=f(i.x,i.y,i.z,256);float3 g=gridData[t];if(g.z==0.){return;}float n[8];int d=0;for(int x=0;x<8;++x){int3 M=i+localGridCellCoords[x];int z=f(M.x,M.y,M.z,256);float3 k=gridData[z];if(k.z==0.){return;}n[x]=k.x;if(k.x<=0.)d|=1<<x;}int z=cubeEdgeFlags[d];if(z==0){return;}float3 y=i;int k=d*16,a[3]={triangleConnectionTable[k+3],triangleConnectionTable[k+4],triangleConnectionTable[k+5]};float3 S=float3(0,0,0),M[3];int D;for(D=0;D<3;++D){int p=a[D];float v=n[edgeConnection[p].x],o=n[edgeConnection[p].y],X=r(v,o);float3 l=y+(vertexOffset[edgeConnection[p].x]-X*edgeDirection[p])*e;M[D]=l;S+=l;}float3 v=cross(M[2]-M[0],M[1]-M[0]);if(abs(v.x+v.y+v.z)>0.){a[0]=triangleConnectionTable[k];a[1]=triangleConnectionTable[k+1];a[2]=triangleConnectionTable[k+2];for(D=0;D<3;++D){int p=a[D];float w=n[edgeConnection[p].x],o=n[edgeConnection[p].y],X=r(w,o);float3 l=y+(vertexOffset[edgeConnection[p].x]-X*edgeDirection[p])*e;M[D]=l;}v+=cross(M[2]-M[0],M[1]-M[0]);a[0]=triangleConnectionTable[k+6];a[1]=triangleConnectionTable[k+7];a[2]=triangleConnectionTable[k+8];for(D=0;D<3;++D){int p=a[D];float w=n[edgeConnection[p].x],o=n[edgeConnection[p].y],X=r(w,o);float3 l=y+(vertexOffset[edgeConnection[p].x]-X*edgeDirection[p])*e;M[D]=l;}v+=cross(M[2]-M[0],M[1]-M[0]);a[0]=triangleConnectionTable[k+9];a[1]=triangleConnectionTable[k+10];a[2]=triangleConnectionTable[k+11];for(D=0;D<3;++D){int p=a[D];float w=n[edgeConnection[p].x],o=n[edgeConnection[p].y],X=r(w,o);float3 l=y+(vertexOffset[edgeConnection[p].x]-X*edgeDirection[p])*e;M[D]=l;}v+=cross(M[2]-M[0],M[1]-M[0]);v=normalize(v);S/=3;float3 w=(S-y)/e;uint o=uint(u(w));float p=m(v);int l=g.y,X=g.z,Y=0;InterlockedAdd(gs_numElements,1,Y);gs_pointCloudData[Y]=int4(c(i.x,i.y,i.z,X),o,p,l);}}[numthreads(MAXTHREADS,MAXTHREADS,MAXTHREADS)]void generatePointCloud(int3 f:SV_DispatchThreadID,uint i:SV_GroupIndex){if(i==0)gs_numElements=0,gs_globalOffset=0;GroupMemoryBarrierWithGroupSync();float e=chunkSize/256;c(f,e,i);GroupMemoryBarrierWithGroupSync();if(i==0)InterlockedAdd(indirectDrawArgs[0],gs_numElements*3,gs_globalOffset),gs_globalOffset/=3;GroupMemoryBarrierWithGroupSync();if(i<gs_numElements)pointCloudData[gs_globalOffset+i]=gs_pointCloudData[i];}[numthreads(MAXTHREADS,MAXTHREADS,MAXTHREADS)]void debugDisplayGridPoints(int3 i:SV_DispatchThreadID){
#if DRAW_DEBUG
int e=f(i.x,i.y,i.z,256);if(gridData[e].z!=0.){int t=debugGridOutPoints.IncrementCounter();float s=chunkSize/256;debugGridOutPoints[t]=c(i,s)+chunkCenter;}
#endif
}float4 n(uint f){int i=(f&255)>>0,e=(f&65280)>>8,u=(f&16711680)>>16;return float4(i/255.,e/255.,u/255.,1.);}[numthreads(4,4,4)]void genMesh(int3 i:SV_DispatchThreadID){float e=chunkSize/256;int t=f(i.x,i.y,i.z,256);float3 s=gridData[t];if(s.z==0.){return;}float a[8];int d=0,u=0;for(int x=0;x<8;++x){int3 g=i+localGridCellCoords[x];int p=f(g.x,g.y,g.z,256);float3 k=gridData[p];if(k.z==0.){return;}a[x]=k.x;if(k.x<=0.)d|=1<<x;}int g=cubeEdgeFlags[d];if(g==0){return;}float3 m=c(i,e),M[12];for(int D=0;D<12;++D){if((g&1<<D)!=0){float z=a[edgeConnection[D].x],o=a[edgeConnection[D].y],X=r(z,o);M[D]=m+(vertexOffset[edgeConnection[D].x]-X*edgeDirection[D])*e;}}int o[16]={-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},z=d*16;for(int S=0;S<5;++S){int p=3*S;if(triangleConnectionTable[z+p]>=0){uint k=meshOutIndices.IncrementCounter();for(int y=0;y<3;++y){int l=triangleConnectionTable[z+p+y],v=o[l];if(v==-1)v=meshOutPoints.IncrementCounter(),o[l]=v;int w=s.y;meshOutPoints[v]=M[l]+chunkCenter;meshOutColors[v]=n(w);meshOutIndices[k][2-y]=v+outMeshIndexOffset;}}}}[numthreads(1,1,1)]void filterSolidsPerChunk(int3 f:SV_DispatchThreadID){int e=f.x+f.y*numChunksX+numChunksX*numChunksY*f.z;float i=chunkSize/256.f,u=chunkSize-i,z=chunkSize*.5;float3 s=float3(-(chunkSize*numChunksX*.5)+z+u*f.x,-(chunkSize*numChunksY*.5)+z+u*f.y,-(chunkSize*numChunksZ*.5)+z+u*f.z);float g=chunkSize*1.732*.5;numSolidsPerChunk[e]=0;int t=updatingChunks[e]-1;updatingChunks[e]=t;for(uint r=0;r<numSolids;++r){float3 M=solidsScale[r];float c=max(M.x,max(M.y,M.z))*1.732,o=length(solidsPos[r]-s)-c;if(o<g){int d=numSolidsPerChunk[e];solidsPerChunk[e].solids[d]=r;d+=1;numSolidsPerChunk[e]=d;if(t<0){for(uint D=0;D<numSolidsUpdated;++D){uint k=solidsUpdated[D];if(k==r){updatingChunks[e]=1;break;}}}}}}